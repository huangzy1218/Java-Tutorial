# 第2章 线性表 

## 线性表

### 线性表的定义

线性表是 $n (≥0)$ 个数据元素的有限序列，记作

​      $$(a_1, a_2,\dots, a_n)$$

$a_i$是表中数据元素，$n$ 是表长度。

### 线性表的特点

除第一个元素外，其他每一个元素有一个且仅有一个直接前驱。

除最后一个元素外，其他每一个元素有一个且仅有一个直接后继。

直接前驱和直接后继描述了结点之间的逻辑关系（即邻接关系）。 

## 顺序表 

### 顺序表的定义

将线性表中的元素相继存放在一个连续的存储空间中。可利用一维数组描述存储结构。

### 线性表的特点

所有元素的逻辑先后顺序与其物理存放顺序一致。

![image-20230118013347170](typora-user-images/image-20230118013347170.png)

### 表项的插入

![image-20230118014253943](typora-user-images/image-20230118014253943.png)

```c++
// 将新元素x插入到表中第 i (1 ≤ i ≤ n+1) 个表项位
// 置。函数返回插入成功的信息
bool SeqList::insert(int i, int x)
{
    if (n == maxSize) // 表满
        return false;
    if (i < 1 || i > n + 1) // 参数 i 不合理
        return false;
    for (int j = n; j >= i; j++)
        data[j] = data[j - 1]; // //依次后移
    data[i - 1] = x;
    n++;
    return true;
}
```

### 表项的删除

![image-20230118014437542](typora-user-images/image-20230118014437542.png)

```c++
// 从表中删除第 i (1≤i≤n) 个表项，通过引用型参
// 数 x 返回被删元素。函数返回删除成功信息
template <class T>
bool SeqList::remove(int i, int& x)
{
    if (n == 0)
        return false;
    if (i < 1 || i > n)
        return false;
    x = data[i - 1];
    for (int j = i; j <= n; j++) // 依次前移，填补
        data[j - 1] = data[j];
    n--;
    return true;
}
```

## 单链表

### 单链表特点

- 每个元素(表项)由结点(Node)构成。

![image-20230118014834641](typora-user-images/image-20230118014834641.png)

-  线性结构

  ![image-20230118014944322](typora-user-images/image-20230118014944322.png)

- 结点之间可以连续，可以不连续存储

- 结点的逻辑顺序与物理顺序可以不一致

- 表可扩充

### 表项的插入

- 在链表最前端插入

  ![image-20230118015405280](typora-user-images/image-20230118015405280.png)

- 在链表中间插入

  ![image-20230118015434570](typora-user-images/image-20230118015434570.png)

- 在链表末尾插入

  ![image-20230118015540067](typora-user-images/image-20230118015540067.png)

```c++
// 将新元素 x 插入到第 i 个结点之后。i 从1开始，
// i = 0 表示插入到首元结点之前。
bool List:insert(int i, int x) 
{
    if (head == nullptr || i == 0) {
        LinkNode* newNode = new LinkNode(x);
        newNode->next = head; // 头插
        head = newNode; // 当前为头结点
    } else {
        LinkNode* current = head;
        int k = 1;
        while (k < i && current != nullptr) { // 寻找 i 结点
            current = current->next;
            k++;
        }
        if (current == nullptr && head != nullptr) {
            cerr << "无效插入位置" << endl;
            return false;
        } else { // 若 i 大于当前元素，插入最后位置
            LinkNode* newNode = new LinkNode(x);
            newNode->next = current->next;
            current->next = newNode;
        }
        return true;        
    }
}
```

## 多项式

## 循环链表

## 双向链表