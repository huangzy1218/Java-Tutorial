# 算法模板

## 二分搜索

```java
int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}

int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 不返回锁定左侧边界
            right = mid - 1;
        }
    }
    // 判断 target 是否存在于 nums 中
    // 此时 target 比所有数都大，返回 -1
    if (left == nums.length) return -1;
    // 判断一下 nums[left] 是不是 target
    return nums[left] == target ? left : -1;
}

int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 不返回锁定右侧边界
            left = mid + 1;
        }
    }
    // 此时 left - 1 索引越界
    if (left - 1 < 0) return -1;
    // 判断一下 nums[left] 是不是 target
    return nums[left - 1] == target ? (left - 1) : -1;
}
```

### Kruskal算法

```java
int Kruskal(int n, int[][] edges) {
    UF uf = new UF(n);
    // 对所有边按照权重从小到大排序
    Arrays.sort(edges, (a, b) -> (a[2] - b[2]));
    // 记录最小生成树的权重之和
    int mst = 0;
    for (int[] edge : edges) {
        int u = edge[0];
        int v = edge[1];
        int weight = edge[2];
        // 若这条边会产生环，则不能加入 mst
        if (uf.connected(u, v)) {
            continue;
        }
        // 若这条边不会产生环，则属于最小生成树
        mst += weight;
        uf.union(u, v);
    }
    // 保证所有节点都被连通
    // 按理说 uf.count() == 1 说明所有节点被连通
    return uf.count() == 1 ? mst : -1;
}

class UF {
    // 连通分量个数
    private int count;
    // 存储每个节点的父节点
    private int[] parent;

    // n 为图中节点的个数
    public UF(int n) {
        this.count = n;
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    // 将节点 p 和节点 q 连通
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);

        if (rootP == rootQ)
            return;

        parent[rootQ] = rootP;
        // 两个连通分量合并成一个连通分量
        count--;
    }

    // 判断节点 p 和节点 q 是否连通
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    // 返回图中的连通分量个数
    public int count() {
        return count;
    }
}
```

## Prim算法

```java
int Prim(List<int[]>[] graph) {
    int n = graph.length;
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
        return a[2] - b[2]; 
    });
	boolean isMST = new boolean[n];
    int mst = 0;
    // 从节点0开始划分
    inMST[0] = 0;
    for (int[] edge : grap[0]) {
        pq.offer(edge);
    }
    while (!pq.isEmpty()) {
        int[] edge = pq.poll();
        int to = edge[1];
        int weight = edge[2];
        // 相邻接点 to 已经在最小生成树中，跳过
        // 否则这条边会产生环
        it (inMST[to]) {
            continue;
        }
        mst += weight;
        inMST[to] = true;
        for (int[] edge : graph[to]) {
            if (inMST[to]) {
                continue;
            }
            pq.offer(edge);
        }
    }
    // 有没有连通的
    for (int i = 0; i < inMST.length; i++) {
        if (!inMST[i]) {
            return -1;
        }
    }
    return mst;
}
```

## Dijkstra算法

```java
int[] dijkstra(int start, List<int[]>[] graph) {
    int n = graph.length;
    int[] distToStart = new int[n + 1];
    Arrays.fill(distToStart, Integer.MAX_VALUE);
    distToStart[start] = 0;
    Queue<int[]> pq = new PriorityQueue<>((a, b) -> {
        return a[1] - b[1];
    });
    // 0记录编号，1记录到起始节点的距离
    pq.offer(new int[] {start, 0});
    while (!pq.isEmpty()) {
        int[] state = pq.poll();
        int curID = state[0];
        int curDist = state[1];
        if (curDist > distToStart[curID]) {
            continue;
        }
        for (int[] nextNode : graph[curID]) {
            int nextID = nextNode[0];
            int nextDist = distToStart[curID] + nextNode[1];
            if (nextDist < distToStart[nextID]) {
                distToStart[nextID] = nextDist;
                pq.offer(new int[] {nextID, nextDist});
            }
        }
    }
    return distToStart;
}
```

