# 第12章 并发

多任务（multitasking）是操作系统的一种能力，看起来可以在同一时刻运行多个程序。

多线程程序在更低一层扩展了多任务的概念：单个程序看起来在同时完成多个任务。每个任务在一个线程（thread）中执行，线程是控制线程的简称。如果一个程序可以同时运行多个线程，则称这个程序是多线程的（multithreaded）。

每个进程都拥有自己的一整套变量，而线程则共享数据。，与进程相比较，线程更“轻量级”，创建、撤销一个线程比启动新进程的开销要小得多。

## 什么是线程

```java
public class ThreadTest {
    public static final int DELAY = 10;
    public static final int STEPS = 100;
    public static final double MAX_AMOUNT = 1000;

    public static void main(String[] args) {
        var bank = new Bank(4, 100000);
        Runnable task1 = () -> {
            try {
                for (int i = 0; i < STEPS; i++)  {
                    double amount = MAX_AMOUNT * Math.random();
                    bank.transfer(0, 1,  amount);
                    Thread.sleep((int) (DELAY * Math.random()));
                }
            }
            catch (InterruptedException e) {}
        };

        Runnable task2 = () -> {
            try {
                for (int i = 0; i < STEPS; i++) {
                    double amount = MAX_AMOUNT * Math.random();
                    bank.transfer(2, 3, amount);
                    Thread.sleep((int) (DELAY * Math.random()));
                }
            }
            catch (InterruptedException e) {}
        };

        new Thread(task1).start();
        new Thread(task2).start();
    }
}

class Bank {
    private final double[] accounts;

    public Bank(int n, double initialBalance) {
        accounts = new double[n];
        Arrays.fill(accounts, initialBalance);
    }

    public void transfer(int from, int to, double amount) {
        if (accounts[from] < amount) {
            return;
        }
        System.out.print(Thread.currentThread());
        accounts[from] -= amount;
        System.out.printf(" %10.2f from %d to %d", amount, from, to);
        accounts[to] += amount;
        System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());
    }

    public double getTotalBalance() {
        double sum = 0;

        for (double a : accounts) {
            sum += a;
        }

        return sum;
    }

    public int size() {
        return accounts.length;
    }
}
```

可以通过建立`Thread` 类的一个子类来定义线程。现在不再推荐这种方法。应当把要并行运行的任务与运行机制解耦合。如果有多个任务，为每个任务分别创建一个单独的线程开销会太大。实际上，可使用线程池。

> 不要调用`Thread` 类或`Runnable` 对象的`run` 方法。直接调用`run`方法只会在同一个线程中执行这个任务一一而没有启动新的线程。

## 线程状态

线程可以有如下6 种状态：

- New（新建）
- Runnable（可运行）
- Blocked（阻塞）
- Waiting（等待）
- Time Waiting（计时等待）
- Terminated（终止）

要确定一个线程的当前状态，只需要调用`getState`方法。

### 新建线程

```java
Thread t = new Thread(r);
```

### 可运行线程

一旦调用`start`方法，线程就处于可运行（runnable）状态。

事实上，运行中的线程有时需要暂停，让其他线程有机会运行。线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完时，操作系统剥夺该线程的运行
权，并给另一个线程一个机会来运行。

### 阻塞和等待线程

当线程处于阻塞或等待状态时，它暂时是不活动的。它不运行任何代码，而且消耗最少的资源。要由线程调度器重新激活这个线程。具体细节取决于它是怎样到达非活动状态的。

- 当一个线程试图获取一个内部的对象锁，而这个锁目前被其他线程占有，该线程就会被阻塞，当其他线程释放这个锁时，该线程会阻塞。
- 当线程等待另一个线程通知调度器出现一个条件时，这个线程会进入等待状态。
- 有几个方法有超时参数，调用这些方法会让线程进入计时等待状态。

### 终止线程

线程会由于以下两个原因之一而终止：

- `run`方法正常退出，线程自然终止
- 因为一个没有捕获的异常终止了`run`方法，使线程意外终止。

具体来说，可以调用线程的`stop`方法杀死一个线程。该方法抛出一个`ThreadDeath` 错误对象，这会杀死线程。不过， `stop`方法已经废弃，不要在你自己的代码中调用这个方法。

## 线程属性

### 中断线程

除了已经废弃的`stop`方法，没有办法可以强制线程终止。不过， inter rupt 方法可以用来请求终止一个线程。

当对一个线程调用`interrupt`方法时，就会设置线程的中断状态。这是每个线程都有的`boolean`标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断。

要想得出是否设置了中断状态，可进行如下操作：

```java
while (!Thread.currentThread().isInterrupted()) {
    do more work
}
```

但是，如果线程被阻塞（`wait`或`sleep`），就无法检查中断状态。这里就要引入`InterruptedException`异常。

没有任何语言要求被中断的线程应当终止。中断一个线程只是要引起它的注意。被中断的线程可以决定如何响应中断。

如果你的循环调用了`sleep`不要检测中断状态，而应当捕获`InterruptedException`异常：

```java
Runnable r = () -> {
    try {
        while (more work to do) {
            do more work
        } catch (IterruptionException e) {
            // thread was interrupted during sleep
        } finally {
            clean up, if required
        }
    }
};
```

> `interrupt`创方法是一个静态方法，它检查当前线程是否被中断。而且，调用interrupted 方法会清除该线程的中断状态。另一方面， `isInterrupted` 方法是一个实例方法，可以用来检查是否有线程被中断。调用这个方法不会改变中断状态。

不要在底层抑制了`InterruptedException`异常，而是选择更有意义的工作：

```java
void mySubTask() {
	try {
        sleep(delay);
    } catch (InterruptedException e) {
        // 中断状态将被清除，并且将收到InterruptedException
        Thread.currentThread().interrupt();
    }
}
```

或者直接捕获：

```java
void mySubTask() throws InterruptedException {
    sleep(delay);
}
```

### 守护线程

可以通过调用

```java
t.setDaemon(true);
```

将一个线程转换为守护线程（daemon thread）。这样一个线程并没有什么魔力。守护线程的唯一用途是为其他线程提供服务。计时器线程就是一个例子，它定时地发送”计时器嘀嗒”信号给其他线程，另外清空过时缓存项的线程也是守护线程。当只剩下守护线程时，虚拟机就会退出。

### 线程名

默认情况下，线程有容易记的名字，如`Thread-2` 。可以用`setName`方法为线程设置任何名字。这在线程转储可能有用。

### 未捕获异常的处理器

线程的`run`方法不能抛出任何检查型异常，但是，非检查型异常（`Error`和`RuntimeException`）可能会导致线程终止。在这种情况下，线程会死亡。

实际上，在线程死亡之前，异常会传递到一个用于处理未捕获异常的处理器。这个处理器必须属于一个实现了`Thread.UncaughtExceptionHandler`接口的类。这个接口只有一个方法：

```java
void uncaughtException(Thread t, Throwable e);
```

可以用`setUncaughtExceptionHandler`方法为任何线程安装一个处理器。也可以用`Thread`类的静态方法`setDefaultUncaughtExceptionHandler`为所有线程安装一个默认的处理器。

> 线程组是可以一起管理的线程的集合。默认情况下，创建的所有线程都属于同一个线程组，但是也可以建立其他的组。由于现在引入了更好的特性来处理线程集合，所以建议不要在你自己的程序中使用线程组。

`ThreadGroup`类实现了`ThreadUncaughtExceptionHandler`接口。它的`uncaughtException`方法执行以下操作：

1. 如果该线程组有父线程组，那么调用父线程组的uncaught Exception 方法。
2. 否则， 如果`Thread.getDefaultExceptionHandler`方法返回一个非`null`的处理器，则调用该
   处理器。
3. 否则，如果`Throwable` 是`ThreadDeath` 的一个实例， 什么都不做。
4. 否则，将线程的名字以及`Throwable` 的栈轨迹输出到`System..err` 

### 线程优先级

默认情况下， 一个线程会继承构造它的那个线程的优先级。可以用`setPriority` 方法提高或降低任何一个线程的优先级。可以将优先级设置为问`MIN_PRIORITY` （在`Thread`类中定义为1 ）与`MAX＿PRIORITY` （定义为10）之间的任何值。`NORM PRIORITY` 定义为5 。

平台的线程优先级别可能比上述的10 个级别多，也可能更少。Windows 有7 个优先级别。Java 的一些优先级会映射到同一个操作系统优先级。

## 同步

在大多数实际的多线程应用中，两个或两个以上的线程需要共享对同数一据的存取。可能会导致对象被破坏。这种情况通常称为竞态条件（race condition） 。

Java 语言提供了一个`synchronized` 关键字来达到这一目的，另外Java 5 引入了`ReentrantLock`类。synchronized 关键字会自动提供一个锁以及相关的“条件” ， 对于大多数需要显式锁的情况，这种机制功能很强大， 也很便利。

### 锁对象

用`ReentrantLock`保护代码块的基本结构如下：

```java
myLock.lock();
try {
	crital section
}
finally {
    myLock.unlock();
}
```

> 要把`unlock`础操作包括在`finally`子句中，这一点至关重要。如果在临界区的代码抛出一个异常，锁必须释放。否则，其他线程将永远阻塞。

这个结构确保任何时刻只有一个线程进入临界区。一旦一个线程锁定了锁对象，其他任何线程都无法通过`lock`语句。

```java
public class Bank {
    private ReentrantLock bankLock = new ReetrantLock();
	public void transfer(int from, int to, int ammount) {
    backLock.lock();
        try {
         	System.out.println(Thread.currentThread());
            accounts[from] -= amount;
        } finally {
            bankLock.unLock();
        }
    }
}
```

这个锁称为重入（reentrant）锁，因为线程可以反复获得已拥有的锁。锁有一个持有计数（hold count）来眼踪对`lock`方法的嵌套调用。

`transfer`方法调用`getTotalBalance`方法，这也会封锁banklock 对象， 此时`banklock`对象的持有计数为2。当`getTotalBalance`方法退出时，持有计数变回1。当`transfer`方法退出的时候，持有计数变为0，线程释放锁。

> 使用`if`判断的话，唤醒后线程会从`wait`之后的代码开始运行，但是不会重新判断`if`条件，直接继续运行`if`代码块之后的代码，而如果使用`while`的话，也会从`wait`之后的代码运行，但是唤醒后会重新判断循环条件。

### 条件对象

通常，线程进入临界区后却发现只有满足了某个条件之后它才能执行。可以使用一个条件对象来管理那些已经获得了一个锁却不能做有用工作的线程。

一个锁对象可以有一个或多个相关联的条件对象。你可以用`newCondition` 方法获得一个条件对象。习惯上会给每个条件对象一个合适的名字来反映它表示的条件。

在成功地通过这个测试之后，但在调用`transfer`方法之前，当前线程完全有可能被中断。

```java
if (bank.getBalance(from) >= amount) {
    // 可能在此时被中断
    bank.transfer(from, to, amount);
}
```

在线程再次运行前， 账户余额可能已经低于提款金额。

```java
bankLock.lock();
try {
	while (account[from] < amount) {
    	// wait
	}
} finally {
    banLock.unlock();
}
```

现在，当账户中没有足够的资金时，将进行等待，直到另一个线程
向账户中增加了资金。但是，这个线程刚刚获得了对`bankLock` 的排他性访问权，因此别的线程没有存款的机会。这里就要引人条件对象。

```java
class Bank {
    private Condition sufficientFunds;
    
    public Bank() {
        suffientFunds = bankLock.newCondition();
    }
}
```

如果`transfer`方法发现资金不足，它会调用：

```java
// 当前线程现在暂停，并放弃锁。这就允许另一个线程执行，我们希望它能增加账户余额
suffientFunds.await();
```

当另一个线程完成转账时，它应该调用：

```java
// 会重新激活等待这个条件的所有线程
sufficientFunds.signalAll();
```

注意`signalAll`调用不会立即激活一个等待的线程。它只是解除等待线程的阻塞，使这些线程可以在当前线程释放锁之后**竞争访问**对象。

另一个方法`signal`只是随机选择等待集中的一个线程，并解除这个线程的阻塞状态。这比解除所有线程的阻塞更高效，但也存在危险，如产生死锁。

```java
public class Bank {
    private final double[] accounts;
    private Lock bankLock;
    private Condition sufficientFunds;

    public Bank(int n, double initialBalance) {
        accounts = new double[n];
        Arrays.fill(accounts, initialBalance);
        bankLock = new ReentrantLock();
        sufficientFunds = bankLock.newCondition();
    }


    public void transfer(int from, int to, double amount) throws InterruptedException {
        bankLock.lock();
        try {
            // 不能进行转账，等待
            while (accounts[from] < amount) {
                sufficientFunds.await();
            }
            System.out.print(Thread.currentThread());
            accounts[from] -= amount;
            System.out.printf(" %10.2f from %d to %d", amount, from, to);
            accounts[to] += amount;
            System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());
            // 释放资源
            sufficientFunds.signalAll();
        } finally {
            bankLock.unlock();
        }
    }

    public double getTotalBalance() {
        bankLock.lock();
        try {
            double sum = 0;

            for (double a : accounts) {
                sum += a;
            }

            return sum;
        } finally {
            bankLock.unlock();
        }
    }

    public int size() {
        return accounts.length;
    }
}
```

### `synchronized` 关键字

对锁和条件的要点做一个总结：

- 锁用来保护代码片段， 一次只能有一个线程执行被保护的代码。
- 锁可以管理试图进入被保护代码段的线程。
- 一个锁可以有一个或多个相关联的条件对象。
- 每个条件对象管理那些已经进入被保护代码段但还不能运行的线程。

`Lock` 和`Condition` 接口允许程序员充分控制锁定。不过，大多数情况下，你并不需要那样控制， 完全可以使用Java 语言内置的一种机制。从1.0 版开始， Java 中的每个对象都有一个内部锁。如果一个方法声明时有`synchronized` 关键字，那么对象的锁将保护整个方法。也就是说，要调用这个方法，线程必须获得内部对象锁。

```java
public sychronized void method {
    method body
}
```

等价于：

```java
public void method() {
	this.intrinsticLock.lock();
    try {
        method body
    } finally {
        this.intrinsticLock.unlock();
    }
}
```

内部对象锁只有一个关联条件。`wait` 方法将一个线程增加到等待集中， `notifyAll/notify`方法可以解除等待线程的阻塞。换句话说，调用`wait` 或`notifyAll`等价于：

```java
condition.await();
condition.signalAll();
```

每个对象都有一个内部锁，并且这个锁有一个内部条件。这个锁会管理试图进人`synchronized` 方法的线程，这个条件可以管理调用了`wait` 的线程。

内部锁和条件存在一些限制。包括：

- 不能中断一个正在尝试获得锁的线程。
- 不能指定尝试获得锁时的超时时间。
- 每个锁仅有一个条件可能是不够的。

> 如果特别需要`Lock/Condition` 结构提供的额外能力， 则使用`Lock/Condition` 。

### 同步块

```java
synchronized (obj) {
    critial section
}
```

> Java 虚拟机对同步方法提供了内置支持。不过，同步块会编译为很长的字节码序列来管理内部锁。

### 监视器

严格的说，锁和条件不是面向对象的。监视器（monitior）有如下特性：

- 监视器是只包含私有字段的类。
- 监视器类的每个对象有一个关联的锁。
- 所有方法由这个锁锁定。换句话说，如果客户端调用。`obj.method`，那么`obj` 对象的锁在方法调用开始时自动获得，并且当方法返回时自动释放该锁。因为所有的字段是私有的，这样的安排可以确保一个线程处理字段时，没有其他线程能够访问这些字段。
- 锁可以有任意多个相关联的条件。

Java 对象在以下3 个重要方面不同于监视器，这削弱了线程的安全性：

- 字段不要求是`private` 。

- 方法不要求是`synchronized`。

- 内部锁对客户是可用的。

### `volatile`字段

`volatile` 关键字为实例字段的同步访问提供了一种免锁机制。如果声明一个字段为`volatile` ，那么编译器和虚拟机就知道该字段可能被另一个线程并发更新。

```java
private boolean done;
public synchronized boolean isDone() {
    return done;
}
public synchronized void setDone() {
    done = true;
}
```

如果另一个线程已经对该对象加锁， `isDone` 和`setDone` 方法可能会阻塞。

在这种情况下，将字段声明为`volatile` 就很合适：

```java
private volatile boolean done;
public boolean isDone() {
    return done;
}
public void setDone() {
    done = true;
}
```

> `volatile` 变量不能提供原子性。不能保证读取、翻转和写入不被中断。当一个线程访问一个变量时，该操作不会被中断，保证数据操作是以原子方式进行的

### `final`变量

将字段声明为`final`，可安全访问一个共享字段。

```java
final var accounts = new HashMap<String, Double>();
```

其他线程会在构造器完成构造之后才看到这个`accounts`变量。

当然，对这个映射的操作并不是线程安全的。如果有多个线程更改和读取这个映射，仍然需要进行同步。

### 原子性

假设对共事变量除了赋值之外并不做其他操作，那么可以将这些共享变量声明为`volatile`。

`java.util.concurrent.atomic` 包中有很多类使用了很高效的机器级指令（而没有使用锁）来保证其他操作的原子性。例如，`Atomiclnteger`类提供了方法`incrementAndGet` 和`decrementAndGet` ,它们分别以原子方式将一个整数进行自增或自减。

```java
AtomicLong number = new AtomicLong();
long id = number.incrementAndGet();
number.updateAndGet(x -> 1);
System.out.println(number);
```

> 类`AtomicInteger`、`AtomicIntegerArray`、`AtomicIntegrFieldUpper`、`AtomicReference`、`AtomicReferenceArray` 和`AtomicReferenceFieldUpdater` 也提供了这些方法。

如果有大量线程要访问相同的原子值， 性能会大幅下降，因为乐观更新需要太多次重试。`LongAdder`和`LongAccumulator` 类解决了这个问题。`LongAdder`包括多个变量（加数）， 其总和为当前值。

```java
LongAdder adder = new LongAdder();
// 不返回原值
adder.increasement();
long total = adder.sum();
```

`LongAccumulator`将这种思想推广到任意的累加操作。

```java
LongAccumulator adder = new LongAccumlator(Long::sum, 0);
adder.accumlator(value);
```

另外`DoubleAdder`和`DoubleAccumulator`也采用同样的方式，只不过处理的是`double`值。

### 死锁

考虑下面的情况：

1. 账户1：: $200
2. 账户2:：$300
3. 线程1 ：从账户l 转$300 到账户2
4. 线程2 ：从账户2 转$400 到账户1

线程1和线程2 显然都被阻塞。因为账户1以及账户2 中的余额都不足以进行转账，两个线程都无法执行下去。

有可能会因为每一个线程要等待而导致所有线程都被阻塞。这样的状态称为死锁（deadlock）。

遗憾的是， Java 编程语言中没有任何东西可以避免或打破这种死锁。必须仔细设计程序，确保不会出现死锁。

### 线程局部变量

有时可能要避免共享变量，使用`ThreadLocal` 辅助类为各个线程提供各自的实例。

要为每个线程构造一个实例，可以使用以下代码：

```java
public static final ThreadLocal<SimpleDateFormat> dateFormat = ThreadLocal.withInital(() -> new SimpleDateFormat("yyyy-MM-dd"));
```

要访问具体的格式化方法，可以调用：

```java
String dateStamp = dateFormat.get().format(new Date());
```

在多个线程中生成随机数也存在类似的问题。`java.util.Random` 类是线程安全的，但是如果多个线程需要等待一个共享的随机数生成器，这会很低效。

可以使用`Threadlocal` 辅助类为各个线程提供一个单独的生成器，不过Java 7 还另外提供了一个便利类。

```java
public static final ThreadLocal<Random> random = ThreadLocal.withInitial(Random::new);
public static void main(String[] args) {
    int randomNum = random.get().nextInt();
    System.out.println(randomNum);
}
// Java 7引入
int randomNum = ThreadLocalRandom.current().nextInt(upperBound);
```

#### 为什么废弃`stop`和`suspend` 方法

最初的Java 版本定义了一个`stop` 方法来终止一个线程，以及一个`suspend` 方法来阻塞一个线程直至另一个线程调用`resume`。`stop` 和`suspend` 方法有一些共同点： 都试图控制一个给定线程的行为，而没有线程的互操作。

`stop` 方法天生就不安全，经验证明`suspend `方法经常会导致死锁。

`stop`方法会终止所有未结束的方法，包括`run`方法。当线程被终止，它会立即释放被它锁定的所有对象的锁。这会导致对象处于不一致的状态。

例如，假设一个`TransferRunnable` 在从一个账户向另一个账户转账的过程中被终止， 钱已经取出，但还没有存入目标账户，现在银行对象就被破坏了。因为锁已经被释放，其他未停止的线程也会观察到这种破坏。当一个线程要终止另一个线程时， 它无法知道什么时候调用`stop`方法是安全的，而什么时候会导致对象被破坏。因此， 该方法已经被废弃。

如果用`suspend`挂起一个持有锁的线程，那么，在线程恢复运行之前这个锁是不可用的。如：如果调用`suspend` 方法的线程试图获得同一个锁，那么程序**死锁**：被挂起的线程等着被恢复， 而将其挂起的线程等待获得锁。

如果想安全地挂起线程，可以引人一个变量`suspendRequested` ，并在`run`方法的某个安全的地方测试它，安全的地方是指在这里该线程没有锁定其他线程需要的对象。当该线程发现`suspendRequested` 变量已经设置，将会继续等待，直到再次可用。

## 线程安全的集合

### 阻塞队列

当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列（ blocking queue ）将导致线程阻塞。在协调多个线程之间的合作时，阻塞队列是一个有用的工具。

阻塞队列方法分为以下3 类， 这取决于当队列满或空时它们完成的动作。如果使用队列作为线程管理工具，将要用到`put` 和`take` 方法。当试图向满队列添加元素或者想从空队列得到队头元素时， `add` 、`remove `和`element `操作会抛出异常。当然，在一个多线程程序中，队列可能会在任何时候变空或变满， 因此， 应当使用`offer`、`poll` 和`peek` 方法作为替代。

> `poll`和`peek`方法返回`null`指向失败。因此，向这些队列插入`null`是违法的。

还有带有超时时间的`offer`方法和`poll`方法。例如：

```java
boolean success = q.offer(x, 100, TimeUnit .MILLISECONDS);
```

尝试在100 毫秒的时间内在队尾插入一个元素。如果成功返回`true`； 否则，如果超时，则返回`false`。

`java.util.concurrent` 包提供了阻塞队列的几个变体。默认情况下， `LinkedBlockingQueue` 的容量没有上界， 但是， 也可以选择指定一个最大容量。`LinkedBlockingDeque`是一个双端队列。`ArrayBlockingQueue` 在构造时需要指定容量，并且有一个可选的参数来指定是否需要公平性。若设置了公平参数，那么等待了最长时间的线程会优先得到处理。通常，公平性会降低性能， 只有在确实非常需要时才使用公平参数。`PriorityBlockingQueue`是一个优先队列，而不是先进先出队列。元素按照它们的优先级顺序移除。

`DelayQueue` 包含实现了`Delayed`接口的对象：

```java
interface Delayed extends Comparable<Delayed> {
    long getDelayed(TimeUnit unit)
}
```

`getDelay` 方法返回对象的剩余延迟。负值表示延迟已经结束。元素只有在延迟结束的情况下才能从`DelayQueue` 移除。同时还需要实现`compareTo`方法，实现堆元素的排序。

Java 7 增加了一个`TransferQueue` 接口， 允许生产者线程等待， 直到消费者准备就绪可以接收元素。如生产者调用`q，transfer(item)`，这个调用会阻塞，直到另一个线程将元素（item） 删除。

```java
public class BlockingQueueTest {
    private static final int FILE_QUEUE_SIZE = 10;
    private static final int SEARCH_THREADS = 100;
    private static final Path DUMMY = Path.of("");
    private static BlockingQueue<Path> queue = new ArrayBlockingQueue<>(FILE_QUEUE_SIZE);

    public static void main(String[] args) {
        try (var in = new Scanner(System.in)) {
            System.out.print("Enter base directory (e.g. /opt/jdk-11-src): ");
            String directory = in.nextLine();
            System.out.print("Enter keyword (e.g. volatile): ");
            String keyword = in.nextLine();

            Runnable enumerator = () -> {
                try {
                    // 枚举当前目录下的文件
                    enumerate(Path.of(directory));
                    // 放置虚拟包，当搜索线程取到这个虚拟对象时，将其放回并终止
                    queue.put(DUMMY);
                } catch (IOException | InterruptedException e) {
                    e.printStackTrace();
                }
            };

            // 查找路径文件线程
            new Thread(enumerator).start();
            // 100个查找线程同时进行
            for (int i = 1; i <= SEARCH_THREADS; i++) {
                Runnable searcher = () -> {
                    try {
                        var done = false;
                        while (!done) {
                            // 检索并删除此队列的头部，必要时等待，直到元素可用
                            Path file = queue.take();
                            if (file == DUMMY) {
                                // 将指定的元素插入此队列，等待空间变为可用
                                queue.put(file);
                                done = true;
                            } else {
                                search(file, keyword);
                            }
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                    } catch (InterruptedException e) {}
                };
                new Thread(searcher).start();
            }
        }
    }

    /**
     * 递归枚举给定目录及其子目录中的所有文件。有关流和文件操作。
     */
    public static void enumerate(Path directory) throws IOException, InterruptedException {
        try (Stream<Path> children = Files.list(directory)) {
            for (Path child : children.collect(Collectors.toList())) {
                if (Files.isDirectory(child)) {
                    enumerate(child);
                }
                else {
                    queue.put(child);
                }
            }
        }
    }

    /**
     * 在文件中搜索给定关键字并打印所有匹配的行。
     * @param file 文件名
     * @param keyword 要搜索的关键字
     */
    public static void search(Path file, String keyword) throws IOException {
        try (var in = new Scanner(file, StandardCharsets.UTF_8)) {
            int lineNumber = 0;
            while (in.hasNextLine()) {
                lineNumber++;
                String line = in.nextLine();
                if (line.contains(keyword)) {
                    System.out.printf("%s:%d:%s%n", file, lineNumber, line);
                }
            }
        }
    }
}
```

我们同时启动了大量搜索线程。每个搜索线程从队列中取出一个文件，打开它，打印所有包含该关键字的行，然后取出下一个文件。为了发出完成信号，枚举线程会在队列中放置一个虚拟对象（类似于在行李输送带上放一个标着“最后一个包”的虚拟包） 。当搜索线程取到这个虚拟对象时，将其放回并终止。

### 高效的映射、集和队列

`java.util.concurrent` 包提供了映射、有序集和队列的高效实现：`ConcurrentHashMap`、`ConcurrentSkipListMap`、`ConcurrentSkipListSet` 和`ConcurrentlinkedQueue`。

与大多数集合不同，这些类的`size`方法不一定在常量时间内完成操作。确定这些集合的当前大小通常需要遍历。有些应用使用庞大的并发散列映射，这些映射太过庞大，以至于无法用`size`方法得到它的大小，因为这个方法只能返回int 。如果一个映射包含超过20 亿个条目，使用`mappingCount` 方法可以把大小作为`long`返回。

集合返回弱一致性（weakly consistent）的迭代器。这意味着迭代器不一定能反映出它们构造之后的所有更改。

并发散列映射可以高效地支持大量阅读器和一定数量的书写器。默认情况下认为可以有至多16个同时运行的书写器线程。

### 映射条目的原子更新

`ConcurrentHashMap` 原来的版本只有为数不多的方法可以实现原子更新。下列代码是线程不安全的：

```java
Long oldValue = map.get(word);
Long newValue = oldValue == null ? 1 : oldValue + 1;
map.put(word, newValue);
```

`get` 和`put`代码永远不会破坏数据结构。不过，由于操作序列不是原子的，所以结果不可预知。

在老版本的Java 中，必须使用replace 操作，它会以原子方式用一个新值替换原值，前提是之前没有其他线程把原值替换为其他值。

```java
do {
	oldValue = map.get(word);
    newValue = oldValue == null ? 1 : oldValue + 1;
} while (!map.replace(word, oldValue, newValue));
```

或者，可以使用一个`ConcurrentHashMap<String, AtomicLong＞`，以及以下更新代码：

```java
map.putIfAbsent(word, new AtomicLong());
map.get(word).incrementAndGet();
```

如今，Java API提供`compute`方法。

```java
map.compute(word, (k, v) -> v == null ? 1 : v + 1);
```

另外还有`computelfPresent` 和`computelfAbsent` 方法，它们分别只在已经有原值的情况下计算新值，或者只在没有原值的情况下计算新值。

```java
public class CHMDemo {
    public static ConcurrentHashMap<String, Long> map = new ConcurrentHashMap<>();

    /**
     * 将给定文件中的所有单词添加到并发哈希映射中
     * @param file 一个文件
     */
    public static void process(Path file)  {
        try (var in = new Scanner(file))  {
            while (in.hasNext())  {
                String word = in.next();
                // 如果指定的键尚未与（非空）值关联，则将其与给定值相关联
                map.merge(word, 1L, Long::sum);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 返回给定目录的所有后代
     * @param rootDir 根目录
     * @return 根目录的所有后代的集合
     */
    public static Set<Path> descendants(Path rootDir) throws IOException {
        // 返回 Stream ，它通过遍历以给定起始文件为根的文件树来延迟填充Path
        try (Stream<Path> entries = Files.walk(rootDir)) {
            return entries.collect(Collectors.toSet());
        }
    }

    public static void main(String[] args)
            throws InterruptedException, ExecutionException, IOException {
        int processors = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors.newFixedThreadPool(processors);
        // 当前路径下
        Path pathToRoot = Path.of(".");
        for (Path p : descendants(pathToRoot)) {
            // 寻找后缀为.java的文件
            if (p.getFileName().toString().endsWith(".java")) {
                executor.execute(() -> process(p));
            }
        }
        // 尝试停止所有正在执行的任务，停止等待任务的处理，并返回等待执行的任务列表
        executor.shutdown();
        // 阻止所有任务在关闭请求之后完成执行，或发生超时，或者当前线程被中断，以先发生者为准
        executor.awaitTermination(10, TimeUnit.MINUTES);
        map.forEach((k, v) -> {
            if (v >= 10) {
                System.out.println(k + " occurs " + v + " times");
            }
        });
    }
}
```

### 对并发散列映射的批操作

Java API 为并发散列映射提供了批操作，即使有其他线程在处理映射，这些操作也能安全地执行。批操作会遍历映射，处理遍历过程中找到的元素。

有3 种不同的操作：

- `search`：（搜索）为每个键或值应用一个函数， 直到函数生成一个非null 的结果。
- `reduce`：（归约）组合所有键或值，这里要使用所提供的一个累加函数。
- `forEach`：为所有键和值应用一个函数。

对于上述各个操作，需要指定一个参数化阈值（parallelism threshold）。如果映射包含的元素多于这个阔值，就会并行完成批操作。

例如，假设我们希望找出第一个出现次数超过1000 次的单词。需要搜索键和值：

```
String reasult = map.search(threshod, (k, v) -> v > 1000 ? k : null);
```

`forEach` 方法有两种形式。第一种形式只对各个映射条目应用一个消费者函数：

```java
map.forEach(thrhold, (k, v) -> System.out.println(k + "->" + v));
```

第二种形式还有一个额外的转换器函数作为参数，要先应用这个函数，其结果会传递到消费者：

```
map.forEach(thrhold, (k, v) -> k + "->" + v, System.out::println);
```

`reduce`操作用一个累加函数组合其输入。

```java
Long sum = mao.reduceValues(threshold, Long::sum);
```

### 并发集视图

可以使用包含“假”值的`ConcurrentHashMap` ，静态newKeySet 方法会生成一个`Set` ， 这实际上是`ConcurrentHashMap<K, Boolean>` 的一个包装
器。创建一个由给定类型的ConcurrentHashMap支持的新`Set`到`Boolean.TRUE` 。

```java
Ser<String> words = ConcurrentHashMap.<String>.newKeySet();
```

`ConcurrentHashMap` 还有第二个`keySet` 方法，它包含一个默认值，为集增加元素时可以使用这个方法：

```java
Set<String> words = map.keySet(1L);
words.add("Java");
```

### 写数组的拷贝

`CopyOnWriteArrayList` 和`CopyOnWriteArraySet` 是线程安全的集合，其中所有更改器会建立底层数组的一个**副本**。当构造一个迭代器的时候，它包含当前数组的一个引用。如果这个数组后来被更改了，迭代器仍然引用旧数组，但是，集合的数组已经替换。因而，原来的迭代器可以访问一致的（但可能过时的）视图，而且不存在任何同步开销。

### 并行数算法

`Arrays`类提供了大量并行化操作。静态`Arrays.parallelSort` 方法可以对一个基本类型值或对象的数组排序。

对对象排序时，可以提供一个Comparator。

```java
Arrays.parallelSort(words, Comparator.comparing(String::length));
```

`parallelSetAll` 方法会用由一个函数计算得到的值填充一个数组。

```java
Arrays.paralleSetAll(values, i - > i % 10);
```

```java
int[] a = new int[10];
Arrays.parallelSetAll(a, i -> i % 10);
Arrays.parallelPrefix(a, (x, y) -> x - y);
System.out.println(Arrays.toString(a));
```

### 较早的安全集合

从Java 的初始版本开始`Vector` 和`Hashtable` 类就提供了动态数组和散列表的线程安全的实现。

实际上， 集合库中提供了一种不同的机制。任何集合类都可以通过使用同步包装器（synchronization wrapper）变成线程安全的：

```java
List<Integer> synchArrayList = Collections.synchronizedList(new ArrayList<>());
Map<String, Integer> synchMap = Collections.synchronizedMap(new HashMap<>());
```

通常最好使用`java.util.concurrent` 包中定义的集合，而不是同步包装器。特别是，`ConcurrentHashMap` 经过了精心实现，假如多个线程访问的是**不同的桶**，它们都能访问`ConcurrentHashMap`而不会相互阻塞。

## 任务和线程池

构造一个新的线程开销有些大， 因为这涉及与操作系统的交互。如果你的程序中创建了大量的生命期很短的线程，那么不应该把每个任务映射到一个单独的线程，而应该使用线程池（thread pool）。线程池中包含许多**准备运行的线程**。为线程池提供一个`Runnable` ，就会有一个线程调用`run`方法。

```
┌─────┐ execute  ┌──────────────────┐
│Task1│─────────>│ThreadPool        │
├─────┤          │┌───────┐┌───────┐│
│Task2│          ││Thread1││Thread2││
├─────┤          │└───────┘└───────┘│
│Task3│          │┌───────┐┌───────┐│
├─────┤          ││Thread3││Thread4││
│Task4│          │└───────┘└───────┘│
├─────┤          └──────────────────┘
│Task5│
├─────┤
│Task6│
└─────┘
  ...
```

### `Callable` 与`Future`

`Runnable` 封装一个异步运行的任务，可想象成一个没有参数和返回值的异步方法。`Callable` 与`Runnable` 类似，但是有返回值。`Callable` 接口是一个参数化的类型，只有一个方法`call` 。

```java
public interface Callable<V> {
    V call() throws Exception;
}
```

`Future`保存异步计算的结果。可以启动一个计算，将Future对象交给某个线程，然后忘掉它。这个`Future` 对象的所有者在结果计算好之后就可以获得结果。

`Future<V＞` 接口有下面的方法：

```java
V get(); // 调用阻塞，直到计算完成
V get(long timeout, TimeUnit unit);
void cancel(boolean mayInterrupt); // 取消计算
boolean isCannceled();
boolean isDone();
```

### 执行器

执行器（Executors）类有许多静态工厂方法，用来构造线程池。Java标准库提供了`ExecutorService`接口表示线程池。

- `FixedThreadPool`：线程数固定的线程池；
- `CachedThreadPool`：线程数根据任务动态调整的线程池；
- `SingleThreadExecutor`：仅单线程执行的线程池。

`newCachedThreadPool` 方法构造一个线程池，会立即执行各个任务，如果有空闲线程可用，就使用现有空闲线程执行任务； 如果没有可用的空闲线程， 则创建一个新线程。

`newFixedThreadPool` 方法构造一个具有固定大小的线程池。如果提交的任务数多于空闲线程数， 就把未得到服务的任务放到队列中。当其他任务完成以后再运行这些排队的任务。

`newSingleThreadExecutor`是一个退化了的大小为1的线程池： 由一个线程顺序地执行所提交的任务（一个接着一个执行）。

如果线程生存期很短，或者大量时间都在阻塞，那么可以使用一个缓存线程池。果线程工作量很大而且并不阻塞，你肯定不希望运行太多线程。
为了得到最优的运行速度，并发线程数等于处理器内核数。在这种情况下，就应当使用固定线程池，即并发线程总数有一个上限。

单线程执行器对于性能分析很有帮助。如果临时用一个单线程池替换缓存或固定线程池，就能测量不使用并发的情况下应用的运行速度会慢多少。

可用下面的方法之一将Runnable 或Callable 对象提交给`Executor`。

使用完一个线程池时，调用`shutdown` 。这个方法启动线程池的关闭序列。被关闭的执行器不再接受新的任务。当所有任务都完成时，线程池中的线程死亡。另一种方法是调用`shutdownNow`。线程池会取消所有尚未开始的任务。

下面总结了在使用连接池时所做的工作：

1. 调用`Executors` 类的静态方法。

2. 调用`submit` 提交`Runnable` 或`Callable` 对象。
3.  保存好返回的`Future` 对象，以便得到结果或者取消任务。
4. 当不想再提交任何任务时，调用`shutdown` 。

```java
public class TheadPoolTest {
    public static void main(String[] args) {
        ExecutorService es = Executors.newFixedThreadPool(4);
        for (int i = 0; i < 6; i++) {
            es.submit(new Task("" + i));
        }
    }
}

class Task implements Runnable {
    private final String name;

    Task(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println("start task " + name);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
        }
        System.out.println("end task " + name);
    }
}
```

我们观察执行结果，一次性放入6个任务，由于线程池只有固定的4个线程，因此，前4个任务会同时执行，等到有线程空闲后，才会执行后面的两个任务。

线程池在程序结束的时候要关闭。使用`shutdown`方法关闭线程池的时候，它会**等待**正在执行的任务先完成，然后再关闭。`shutdownNow`会立刻停止正在执行的任务，`awaitTermination()`则会等待指定的时间让线程池关闭。

```java
ExecutorService executor = Executors.newCachedThreadPool();

Callable<Integer> task = new Callable<Integer>() {
@Override
public Integer call() throws Exception {
Scanner scanner = new Scanner(System.in);
int a = scanner.nextInt();
int b = scanner.nextInt();
return a + b;
}
};
Future<Integer> target = executor.submit(task);
System.out.println(target.get());
executor.shutdown();
```

想创建指定动态范围的线程池，可采用如下方式：

```java
static final int MAX = 10;
static final int MIN = 4;

ExecutorService es = new ThreadPoolExecutor(MIN, MAX, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
```

### 控制任务组

我们已经了解了如何使用一个执行器服务作为线程池来提高任务执行的效率。有时，使用执行器有更策略性的原因：需要控制一组相关的任务。例如，可以在执行器中使用`shutdownNow` 方法取消所有的任务。

`invokeAny` 方法提交一个`Callable` 对象集合中的所有对象，并返回某个已完成任务的结果。我们不知道返回的究竟是哪个任务的结果，这往往是最快完成的那个任务。对于搜索问题，如果我们愿意接受任何一种答案，就可以使用这个方法。

`invokeAll` 方法提交一个`Callable` 对象集合中的所有对象，这个方法会阻塞， 直到所有任务都完成，并返回表示所有任务答案的一个`Future` 对象列表。

```java
public class ExecutorDemo {
    /**
     * 计算文件中给定单词的出现次数。
     * @return 单词在给定单词中出现的次数
     */
    public static long occurrences(String word, Path path) {
        try (var in = new Scanner(path)) {
            int count = 0;
            while (in.hasNext()) {
                if (in.next().equals(word)) {
                    count++;
                }
            }
            return count;
        } catch (IOException ex) {
            return 0;
        }
    }

    /**
     * 返回给定目录的所有后代
     * @param rootDir 根目录
     * @return 根目录的所有后代的集合
     */
    public static Set<Path> descendants(Path rootDir) throws IOException {
        try (Stream<Path> entries = Files.walk(rootDir)) {
            return entries.filter(Files::isRegularFile)
                    .collect(Collectors.toSet());
        }
    }

    /**
     * 生成在文件中搜索单词的任务
     * @param word 查找的单词
     * @param path 要在其中搜索的文件
     * @return 成功后生成路径的搜索任务
     */
    public static Callable<Path> searchForTask(String word, Path path) {
        return () -> {
            try (var in = new Scanner(path)) {
                while (in.hasNext()) {
                    if (in.next().equals(word)) {
                        return path;
                    }
                    // 当前线程被中断。如果底层线程被中断，搜索任务在终止之前要
                    // 打印一个消息，使我们能看到其他任务确实已经取消。
                    if (Thread.currentThread().isInterrupted()) {
                        System.out.println("Search in " + path + " canceled.");
                        return null;
                    }
                }
                // 一个都没找到触发异常
                throw new NoSuchElementException();
            }
        };
    }

    public static void main(String[] args)
            throws InterruptedException, ExecutionException, IOException {
        try (var in = new Scanner(System.in)) {
            System.out.print("Enter base directory (e.g. /opt/jdk-9-src): ");
            String start = in.nextLine();
            System.out.print("Enter keyword (e.g. volatile): ");
            String word = in.nextLine();

            // 找到该目录的所有文件
            Set<Path> files = descendants(Path.of(start));
            var tasks = new ArrayList<Callable<Long>>();
            // 线程池管理多线程，减小开销
            for (Path file : files) {
                Callable<Long> task = () -> occurrences(word, file);
                tasks.add(task);
            }
            ExecutorService executor = Executors.newCachedThreadPool();
            //改用单个线程执行器来查看是否多个线程
            // 加快搜索速度
            // ExecutorService executor = Executors.newSingleThreadExecutor();

            Instant startTime = Instant.now();
            List<Future<Long>> results = executor.invokeAll(tasks);
            long total = 0;
            for (Future<Long> result : results) {
                total += result.get();
            }
            Instant endTime = Instant.now();
            System.out.println("Occurrences of " + word + ": " + total);
            System.out.println("经过时间: "
                    + Duration.between(startTime, endTime).toMillis() + " ms");

            var searchTasks = new ArrayList<Callable<Path>>();
            for (Path file : files) {
                searchTasks.add(searchForTask(word, file));
            }
            // 优化搜索，输出第一次找到word的文件（随机）
            Path found = executor.invokeAny(searchTasks);
            System.out.println(word + " occurs in: " + found);

            // 单线程执行器不是
            if (executor instanceof ThreadPoolExecutor) {
                // 如初最大的线程池容量
                System.out.println("Largest pool size: "
                        + ((ThreadPoolExecutor) executor).getLargestPoolSize());
            }
            executor.shutdown();
        }
    }
}
```

### `fork-join`框架

有些应用使用了大量线程，但其中大多数都是空闲的。举例来说，一个Web 服务器可能会为每个连接分别使用一个线程。另外一些应用可能对每个处理器内核分别使用一个线程，以完成计算密集型任务，如图像或视频处理。

这就是Fork/Join任务的原理：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。

```java
if (problemSize < threshold) {
    solve problem directly
} else {
    break problem into subproblem
}
```

```java
public class ForkJoinTest {
    public static void main(String[] args) {
        final int SIZE = 10000000;
        var numbers = new double[SIZE];
        for (int i = 0; i < SIZE; i++) {
            numbers[i] = Math.random();
        }
        var counter = new Counter(numbers, 0, numbers.length, x -> x > 0.5);
        var pool = new ForkJoinPool();
        Instant startTime = Instant.now();
        // 开始执行此任务，必要时等待其完成，并返回其结果
        pool.invoke(counter);
        Instant endTime = Instant.now();
        // 完成时返回结果
        System.out.println("执行时间：" + Duration.between(startTime, endTime).toMillis() + "ms");
        System.out.println(counter.join());
    }
}

class Counter extends RecursiveTask<Integer> {
    public static final int THRESHOLD = 1000;
    private double[] values;
    private int from;
    private int to;
    private DoublePredicate filter;

    public Counter(double[] values, int from, int to, DoublePredicate filter) {
        this.values = values;
        this.from = from;
        this.to = to;
        this.filter = filter;
    }

    protected Integer compute() {
        if (to - from < THRESHOLD) {
            int count = 0;
            for (int i = from; i < to; i++) {
                // 根据给定的参数计算此谓词
                if (filter.test(values[i])) {
                    count++;
                }
            }
            return count;
        } else {
            int mid = (from + to) / 2;
            var first = new Counter(values, from, mid, filter);
            var second = new Counter(values, mid, to, filter);
            invokeAll(first, second);
            // 返回完成时的计算结果
            return first.join() + second.join();
        }
    }
}
```

## 异步计算

### 可完成`Future`

当有一个`Future` 对象时，需要调用`get`来获得值，这个方法会阻塞，直到值可用。

`CompletableFuture` 类实现了Future 接口，它提供了获得结果的另一种机制。你要注册一个回调， 一旦结果可用，就会（在某个线程中）利用该结果调用这个回调。

```java
CompleteFuture<String> f = new CompleteFuture<>();
f.thenAccept(s -> Process the result s);
```

通过这种方式，无须阻塞就可以在结果可用时对结果进行处理。

`CompletableFuture` 可以采用两种方式完成：得到一个结果，或者有一个未捕获的异常。要处理这两种情况，可以使用`whenComplete`方法。

```java
f.whenComplete((s, t) -> {
    if (t == null) {
        process the result;
    } else {
        process the Throwable t;
    }
})
```

`CompletableFuture` 之所以被称为是可完成的，是因为你可以手动地设置一个完成值。

```
public class CompletableFutureTest {
    public static void main(String[] args) throws InterruptedException {
        // 创建异步执行任务
        CompletableFuture<Double> cf = CompletableFuture.supplyAsync(CompletableFutureTest::fetchPrice);
        // thenAccept(Comsumer<T>)
        cf.thenAccept(result -> {
            System.out.println("price: " + result);
        });
        // 执行异常
        cf.exceptionally(e -> {
           e.printStackTrace();
           return null;
        });
        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭
        Thread.sleep(200);
    }

    static Double fetchPrice() {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
        }
        if (Math.random() < 0.3) {
            throw new RuntimeException("fetch price failed");
        }
        return 5 + Math.random() * 20;
    }
}
```

创建一个`CompletableFuture`是通过`CompletableFuture.supplyAsync()`实现的，它需要一个实现了`Supplier`接口的对象：

```java
public interface Supplier<T> {
	T get();
}
```

同理，`Consumer`对象实现接口：

```java
public interface Consumer<T> {
	void accept(T t);
}
```

### 组合可完成`Future`

`CompleteFuture`的优势在于多个任务可串行执行。

两个`CompletableFuture`实现串行操作如下：

```java
CompletableFuture<String> cfQuery = CompletableFuture.supplyAsync(() -> {
    return queryCode("中国石油");
});
// cfQuery成功后继续执行下一个
// 返回一个新的CompletionStage，当该阶段正常完成时，使用此阶段的默认异步执行工具执行，该阶段的结果作为所提供函数的参数
CompletableFuture<Double> cfFetch = cfQuery.thenApplyAsync((code) -> {
    return fetchPrice(code);
});
cfFetch.thenAccept((result) -> {
    System.out.println("price:" + result);
});
// 主线程不要立即结束
Thread.sleep(2000);
}

static String queryCode(String name) {
    try {
        Thread.sleep(100);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return "601857";
}
static Double fetchPrice(String code) {
    try {
        Thread.sleep(100);
    } catch (InterruptedException ignored) {
    }
    return 5 + Math.random() * 20;
}
```

多个`CompletableFuture`还可以并行执行。

```java
// 同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：
public static void main(String[] args) throws InterruptedException {
    CompletableFuture<String> cfQueryFromSina = CompletableFuture.supplyAsync(() -> {
        return queryCode("中国石油", "https://finance.sina.com.cn/code/");
    });
    CompletableFuture<String> cfQueryFrom163 = CompletableFuture.supplyAsync(() -> {
        return queryCode("中国石油", "https://money.163.com/code/");
    });
    // 合并
    CompletableFuture<Object> cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);
    CompletableFuture<Double> cfFetchFromSina = cfQuery.thenApplyAsync((code) -> {
        return fetchPrice((String) code, "https://finance.sina.com.cn/code/");
    });
    CompletableFuture<Double> cfFetchFrom163 = cfQuery.thenApplyAsync((code) -> {
        return fetchPrice((String) code, "https://finance.163.com.cn/code/");
    });
    CompletableFuture<Object> cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);
    cfFetch.thenAccept((result) -> {
        System.out.println("price: " + result);
    });
    Thread.sleep(200);
}

static String queryCode(String name, String url) {
    try {
        Thread.sleep(100);
        // 查询操作
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return "601857";
}
static Double fetchPrice(String code, String url) {
    try {
        Thread.sleep((long) (Math.random() * 100));
    } catch (InterruptedException e) {
    }
    System.out.println("query price from " + url + "...");
    try {
        Thread.sleep(100);
    } catch (InterruptedException ignored) {
    }
    return 5 + Math.random() * 20;

```

```
                        ┌─────────────┐ ┌─────────────┐
                        │ Query Code  │ │ Query Code  │
                        │  from sina  │ │  from 163   │
                        └─────────────┘ └─────────────┘
                               │               │
                               └───────┬───────┘
                                       ▼
                                ┌─────────────┐
                                │    anyOf    │
                                └─────────────┘
                                       │
                               ┌───────┴────────┐
                               ▼                ▼
                        ┌─────────────┐  ┌─────────────┐
                        │ Query Price │  │ Query Price │
                        │  from sina  │  │  from 163   │
                        └─────────────┘  └─────────────┘
                               │                │
                               └────────┬───────┘
                                        ▼
                                 ┌─────────────┐
                                 │    anyOf    │
                                 └─────────────┘
                                        │
                                        ▼
                                 ┌─────────────┐
                                 │Display Price│
                                 └─────────────┘
```

`CompletableFuture`的优点是：

- 异步任务结束时，会自动回调某个对象的方法；
- 异步任务出错时，会自动回调某个对象的方法；
- 主线程设置好回调后，不再关心异步任务的执行。

最后我们注意`CompletableFuture`的命名规则：

- `xxx()`：表示该方法将继续在已有的线程中执行；
- `xxxAsync()`：表示将异步在线程池中执行。

## 进程

可以使用`ProcessBuilder`和`Process` 类zhi行新的程序。`Process` 类在一个单独的操作系统进程中执行一个命令，允许我们与标准输入、输出和错误流交互。`ProcessBuilder`类则允许我们配置Process 对象。

### 建立一个进程

```java
var builder = new ProcessBuilder("gcc", "myapp.c");
```

 第一个字符串必须是一个可执行的命令，而不是一个shell 内置命令。例如，要在Windows 中运行`dir` 命令，就需要提供字符串”`cmd.exe""/C`”和"`dir`”来建立进程。

每个进程都有一个工作目录，用来解析相对目录名。默认情况下，进程的工作目录与虚拟机相同，通常是启动java 程序的那个目录。可以用`directory`方法改变工作目录：

```java
builder = builder.directory(path.toFile());
```

接下来，要指定如何处理进程的标准输入、输出和错误流。默认情况下，它们分别是一个管道，可以用以下方法访问：

```
OutputStream processIn = p.getOutputStream();
InputStream processIn = p.getInputStream();
InputStream processIn = p.getErrorStream();
```

注意，进程的输入流是JVM 的一个输出流。可以指定新进程的输入、输出和错误流与JVM 相同。如果用户在一个控制台运行JVM，所有用户输入都会转发到进程，而进程的输出将显示在控制台上。可以调用：

```java
builder.redirectID();
```

通过提供`File `对象，可以将进程流重定向到文件：

```java
builder.redirectInput(inputFile)
	.redirectOutput(outputFile)
	·redirectError(erroFile);
```

进程启动时， 会创建或删除输出和错误文件。要追加到现有的文件，可以使用：

```java
builder.redirectOutput(ProcessBuilder.Redirect.appendTo(outputFile));
```

合并输出和错误流通常很有用，这样就能按进程生成这些消息的顺序显示输出和错误消息。可以调用：

```java
builder. redirectErrorStream(true);
```

修改进程的环境变量，你需要得到构建器的环境（由运行JVM的那个进程的环境变量初始化），然后加人或删除环境变量条目。

```java
ProcessBuilder builder = new ProcessBuilder();
Map<String, String> env = builder.environment();
for (Map.Entry<String, String> entry : env.entrySet()) {
    System.out.println("" + entry.getKey() + "->" + entry.getValue());
```

```java
Map<String, String> env = builder.enviroment();
env.put("LANG", "fr_FR");
env.remove("JAVA_HOME");
```

### 运行一个进程

配置了构建器之后，要调用它的`start`方法启动进程。

```java
Process process = new ProcessBuilder("/bin/ls", "-l")
    .directory(Path.of("/tmp").toFile())
    .start();
try (var in = new Scanner(process.getInputStream())) {
    while (in.hasNextLine()) {
        System.out.println(in.nextLine());
    }
}
```

要等待进程完成，可以调用：

```java
int result = process.waitFor();
long delay = ;
if (process.waitFor(delay, TimeUnit.SECONDS)) {
	int result = process.exitValue();   
} else {
    process.destroyForcibly();
}
```

最后会在进程完成时接收到一个异步通知。调用`process.onExit()` 会得到一个`CompletableFuture<Process>` ，可以用来调度任何动作。

```java
process.onExit().thenAccept(
	p -> System.out.println("Exit value: " + p.exitValue()));
```

### 进程句柄

要获得程序启动的一个进程的更多信息，或者想更多地了解你的计算机上正在运行的任何其他进程，可以使用`ProcessHandle` 接口。在运行的任何其他进程，可以使用`ProcessHandle` 接口。

何其他进程，可以使用ProcessHandle 接口。可以用4 种方式得到一个ProcessHandle:
1. 给定一个`Process` 对象`p`，`p.toHandle()`会生成它的`ProcessHandle` 。
2. 给定一个`long`类型的操作系统进程ID，`ProcessHandle.of(id)`可以生成这个进程的句柄。
3. `Process.current()`是运行这个Java 虚拟机的进程的句柄。
4. `ProcessHandle.allProcesses()`可以生成对当前进程可见的所有操作系统进程的`Strearn
<ProcessHandle>` 。

给定一个进程句柄，可以得到它的进程ID 、父进程、子进程和后代进程：

```java
long pid = handle.pid();
Optional<ProcessHandle> parent = handle.parent();
Stream<ProcessHandle> children = handle.children();
Stream<ProcessHandle> descendants = handle.descendants();
```

所有这些方法都返回`Optional` 值，因为可能某个特定的操作系统不能报告这个信息。

要监视或强制进程终止，与`Process` 类一样，`ProcessHandle`接口也有`isAlive` 、`supportsNormalTermination`、`destroy`、`destroyForcibly` 和`onExit` 方法。不过，没有对应`waitFor`的方法。