# 哈里巴巴Java开发

## 编程规约

### 命名风格

1. 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。

2. 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。

3. 类名使用UpperCamelCase风格，必须遵从驼峰形式。

4. 方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式。

5. 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。

6. 抽象类命名使用`Abstract`或`Base`开头；异常类命名使用`Exception`结尾；测试类命名以它要测试的类的名称开始，以`Test`结尾。

7. 中括号是数组类型的一部分，数组定义如下：`String[] args`

8. POJO类中布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误。

9. 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。

10. 杜绝完全不规范的缩写，避免望文不知义。

11. 如果使用到了设计模式，建议在类名中体现出具体模式。

12. 接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。

13. 枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。

14. 各层命名规约：

    - 获取单个对象的方法用`get`做前缀。

    - 获取多个对象的方法用`list`做前缀。 
    - 获取统计值的方法用`count`做前缀。 
    - 插入的方法用`save`（推荐）或`insert`做前缀。 
    -  删除的方法用`remove`（推荐）或`delete`做前缀。 
    - 修改的方法用`update`做前缀。


### 常量定义

1. 不允许任何魔法值（即未经定义的常量）直接出现在代码中。

2. `long`或者`Long`初始赋值时，必须使用大写的`L`，不能是小写的`l`，小写容易跟数字1混淆，造成误解。

3. 不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：`CacheConsts`下；系统配置相关的常量放在类：`ConfigConsts`下。 说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。

4. 常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。

   - 跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下。 

   - 应用内共享常量：放置在一方库的modules中的constant目录下。
   - 子工程内部共享常量：即在当前子工程的constant目录下。
   - 包内共享常量：即在当前包下单独的constant目录下。
   - 类内共享常量：直接在类内部`private static final`定义。
   - 如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。

### 代码格式

1. 大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则： 

   - 左大括号前不换行。 
   - 左大括号后换行。 
   - 右大括号前换行。 
   - 右大括号后还有`else`等代码则不换行；表示终止的右大括号后必须换行。

2. 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。

3. `if/for/while/switch/do`等保留字与括号之间都必须加空格。

4. 任何二目、三目运算符的左右两边都需要加一个空格。

5. 缩进采用4个空格，禁止使用tab字符。

   ```java
   public static void main(String[] args) {
       String say = "hello";
       int flag = 0;
       if (flag == 0) {
           System.out.println(say);
       }
       
       if (flag == 1) {
           System.out.println("word");
       } else {
           System.out.println("ok");
       }
   }
   ```

6. 单行字符数限不超过 120 个，超出需要换行时 个，超出需要换行时遵循如下原则：

   - 第二行相对一缩进 4个空格，从第三行开始不再继续缩进参考示例。 
   - 运算符与下文一起换行。 
   - 方法调用的点符号与下文一起换行。 
   - 在多个参数超长，在逗号后换行。 
   - 在括号前不要换行。

   ```java
   StringBuffer sb = new StringBuffer();
   sb.append("zi").append("xin")
       .append("huang")
       .append("huang")
   ```

7. 方法参数在定义和传入时，多个参数逗号后边必须加空格。

8. IDE的text file encoding设置为UTF-8; IDE中文件的换行符使用Unix格式，不要使用windows格式。

9. 没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。

10. 方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。

### OOP规约

1. 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。

2. 所有的覆写方法，必须加`@Override注`解。

3. 相同参数类型，相同业务含义，才可以使用Java的可变参数，避免使用`Object`。

4. 外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加`@Deprecated`注解，并清晰地说明采用的新接口或者新服务是什么。

5. 不能使用过时的类或方法。

6. `Object`的`equals`方法容易抛空指针异常，应使用常量或确定有值的对象来调用`equals`。

   ```java
   "test".equals(object);
   ```

7. 所有的相同类型的包装类对象之间值的比较，全部使用`equals`方法比较。

8. 关于基本数据类型与包装数据类型的使用标准如下：

   - 所有的POJO类属性必须使用包装数据类型。
   - RPC方法的返回值和参数必须使用包装数据类型。
   - 所有的局部变量使用基本数据类型。

9. 定义DO/DTO/VO等POJO类时，不要设定任何属性默认值。

10. 序列化类新增属性时，请不要修改`serialVersionUID`字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改`serialVersionUID`值。

11. 构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在`init`方法中。

12. POJO类必须写`toString`方法。使用IDE的中工具：source> generate toString时，如果继承了另一个POJO类，注意在前面加一下`super.toString`。

13. 使用索引访问用`String`的`split`方法得到的数组时，需做最后一个分隔符后有无内容的检查。

14. 当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。

15. 类内方法定义顺序依次是：公有方法或保护方法 > 私有方法 > getter/setter方法。

16. `setter`方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在`getter/setter`方法中，不要增加业务逻辑，增加排查问题的难度。

17. 循环体内，字符串的连接方式，使用`StringBuilder`的`append`方法进行扩展。

18. `final`可以声明类、成员变量、方法、以及本地变量，下列情况使用`final`关键字：

    - 不允许被继承的类，如：`String`类。 

    - 不允许修改引用的域对象，如：POJO类的域变量。
    - 不允许被重写的方法，如：POJO类的`setter`方法。
    -  不允许运行过程中重新赋值的局部变量。 
    - 避免上下文重复使用一个变量，使用`final`描述可以强制重新定义一个变量，方便更好地进行重构。

19. 慎用`Object`的`clone`方法。

20. 类成员与方法访问控制从严：

    - 如果不允许外部直接通过`new`来创建对象，那么构造方法必须是`private`。 
    - 工具类不允许有`public`或`default`构造方法。 
    - 类非`static`成员变量并且与子类共享，必须是`protected`。 
    - 类非`static`成员变量并且仅在本类使用，必须是`private`。 
    - 类`static`成员变量如果仅在本类使用，必须是`private`。 
    - 若是`static`成员变量，必须考虑是否为`final`。 
    - 类成员方法只供类内部调用，必须是`private`。 
    - 类成员方法只对继承类公开，那么限制为`protected`。

### 集合处理

1. 关于`hashCode`和equals的处理，遵循如下规则：
   - 只要重写`equals`，就必须重写`hashCode`。
   - 因为`Set`存储的是不重复的对象，依据`hashCode`和`equals`进行判断，所以`Set`存储的对象必须重写这两个方法。
   - 如果自定义对象做为`Map`的键，那么必须重写`hashCode`和`equals`。
2. ArrayList`的`subList`结果不可强转成`ArrayList`。
3. 在`subList`场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生`ConcurrentModificationException` 异常。
4. 使用集合转数组的方法，必须使用集合的`toArray(T[] array)`
5. 使用工具类`Arrays.asList()`把数组转换成集合时，不能使用其修改集合相关的方法，它的`add/remove/clear`方法会抛出`UnsupportedOperationException`异常。
6. 泛型通配符`<? extends T>`来接收返回的数据，此写法的泛型集合不能使用`add`方法，而`<? super T>`不能使用`get`方法，做为接口调用赋值时易出错。
7. 不要在foreach循环里进行元素的`remove/add`操作。`remove`元素请使用`Iterator`方式，如果并发操作，需要对`Iterator`对象加锁。
8. 在JDK7版本及以上，`Comparator`要满足如下三个条件，不然`Arrays.sort`，`Collections.sort`会报`IllegalArgumentException`异常。
   - x，y的比较结果和y，x的比较结果相反。
   - x>y，y>z，则x>z。
   - x=y，则x，z比较结果和y，z比较结果相同。
9. 集合初始化时，指定集合初始值大小。
10. 使用`entrySet`遍历Map类集合KV，而不是`keySet`方式进行遍历。 
11. 合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。
12. 利用`Set`元素唯一的特性，可以快速对一个集合进行去重操作，避免使用`List`的`contains`方法进行遍历、对比、去重操作。

### 并发处理

   

1. 获取单例对象需要保证线程安全，其中的方法也要保证线程安全。

2. 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。

   ```java
   public class TimerTaskThread extends Thread {
       public TimerTaskThread() {
           super.setName("TimerTaskThread");
       }
   }
   ```

3. 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。

4. 线程池不允许使用`Executors`去创建，而是通过 去创建，而是通过 去创建，而是通过 `ThreadPoolExecutor`的方式。

5. `SimpleDateFormat` 是线程不安全的类，一般不要定义为`static`变量，如果定义为`static`，必须加锁，或者使用`DateUtils`工具类。

6. 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。

7. 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。

### 控制语句



1. 在一个`switch`块内，每个case要么通过`break/return`等来终止，在一个`switch`块内，都必须包含一个`default`语句并且放在最后，即使它什么代码也没有。

2. 在`if/else/for/while/do`语句中必须使用大括号。即使只有一行代码。

3. 表达异常的分支时，少用if-else方式，这种方式可以改写成：

   ```java
   if (condition) {
   	...
        return onj;
   }
   // else业务逻辑
   ```

4. 除常用方法（如getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。

5. 循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作。

### 注释规约

1. 类、类属性、类方法的注释必须使用Javadoc规范。
2. 所有的抽象方法（包括接口中的方法）必须要用Javadoc注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。
3. 所有的类都必须添加创建者和创建日期。
4. 方法内部单行注释，在被注释语句上方另起一行，使用`//`注释。方法内部多行注释使用`/* */`注释，注意与代码对齐。
5. 所有的枚举类型字段必须要有注释，说明每个数据项的用途。
6. 代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。
7. 合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。
8. 对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。
9. 好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。
10. 特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。

## 异常日志

### 异常处理

1. Java 类库中定义的一类`RuntimeException`可以通过预先检查进行规避，而不应该通过catch 来处理，比如：`IndexOutOfBoundsException`，`NullPointerException`等等。
2. 异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。
3. 对大段代码进行try-catch，这是不负责任的表现。catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。
4. `finally`块必须对资源对象、流对象进行关闭，有异常也要做try-`catch`。
5. 不能在`finally`块中使用`return`，fina~lly块中的`return`返回后方法结束执行，不会再执行try块中的`return`语句。

## MySQL数据库

### 建表规约

1. 表达是与否概念的字段，必须使用`is_xxx`的方式命名，数据类型是`unsigned tinyint`。
2. 表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。
3. 表名不使用复数名词。
4. 禁用保留字，如`desc`、`range`、`match`、`delayed`等。
5. 主键索引名为`pk_字段名`；唯一索引名为`uk_字段名`；普通索引名则为`idx_字段名`。
6. 小数类型为`decimal`，禁止使用`float`和`double`。
7. 如果存储的字符串长度几乎相等，使用`char`定长字符串类型。
8. `varchar`是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为`text`，独立出来一张表，用主键来对应，避免影响其它字段索引效率。
9. 表必备三字段：`id, gmt_create, gmt_modified`。其中id必为主键，类型为unsigned bigint、单表时自增、步长为1。`gmt_create, gmt_modified`的类型均为`date_time`类型。
10. 表的命名最好是加上“业务名称_表的作用”。
11. 库名与应用名称尽量一致。
12. 字段允许适当冗余，以提高查询性能，但必须考虑数据一致。
13. 单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。
14. 合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。

### 



